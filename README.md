# csig

`csig` — утилита для индексации и поиска сигнатур функций в C/C++-коде с использованием `libclang`.

Основные режимы:
- `index` — построить/обновить индекс проекта в SQLite.
- `search` — найти похожие функции по имени и/или сигнатуре.
- `tui` — интерактивный интерфейс в терминале (Textual).

## Что умеет

- Индексирует файлы с расширениями: `.c`, `.cc`, `.cpp`, `.cxx`, `.c++`, `.h`, `.hh`, `.hpp`, `.hxx`.
- Хранит индекс в `SQLite` (по умолчанию `csig.sqlite3` в корне проекта).
- Повторная индексация инкрементальная: неизмененные файлы (по `mtime + size`) пропускаются.
- Поиск нечёткий: ранжирование по расстоянию Левенштейна для имени и нормализованной сигнатуры.

## Быстрый старт

### 1. Требования

- Python 3.10+ (в проекте проверено на Python 3.13)
- `clang` Python bindings (ставится через `pip`, см. `requirements.txt`)
- системная библиотека `libclang`
- (желательно) C/C++ компилятор в `PATH` (`cc`, `clang` или `gcc`)

### 2. Установка зависимостей

```bash
python -m venv .venv
. .venv/bin/activate          # Linux/macOS
# .venv\Scripts\Activate.ps1  # Windows PowerShell

python -m pip install -r requirements.txt
```

### 3. Настройка `libclang` (если не подхватился автоматически)

Если при запуске видите ошибку инициализации `libclang`, укажите путь вручную:

```bash
# Linux/macOS
export LIBCLANG_PATH=/path/to/libclang

# Windows PowerShell
$env:LIBCLANG_PATH="C:\Program Files\LLVM\bin"
```

Примечание: указывать нужно каталог, где лежит библиотека `libclang` (`libclang.so`/`libclang.dylib`/`libclang.dll`).

## Как запустить

### Индексация проекта

```bash
python csig.py index .
```

С полезными параметрами:

```bash
python csig.py index . --db ./.cache/csig.sqlite3 --workers 8
```

### Поиск (CLI)

Поиск по сигнатуре:

```bash
python csig.py search . "int (int, int)"
```

Поиск по имени + сигнатуре:

```bash
python csig.py search . "add :: int (int, int)" --top 10
```

### Интерактивный режим (TUI)

```bash
python csig.py tui .
```

## Мини-демо на этом репозитории

В репозитории есть файл `test.c`, поэтому можно сразу проверить:

```bash
python csig.py index .
python csig.py search . "add :: int (int, int)"
python csig.py search . "int (const char *)"
```

`search` перед запросом автоматически запускает обновление индекса, чтобы база была актуальной.

## Частые проблемы и решения

### 1. `Failed to initialize libclang ...`

Причина: Python-пакет `clang` установлен, но системная библиотека `libclang` недоступна.

Что делать:
- Установить LLVM/Clang:
  - Windows: установить LLVM (например, в `C:\Program Files\LLVM`)
  - Linux: установить пакет `libclang`/`llvm` из менеджера пакетов
  - macOS: установить LLVM (Homebrew)
- Выставить `LIBCLANG_PATH` к каталогу с `libclang`.
- Перезапустить терминал/сессию и повторить запуск.

### 2. Ошибки парсинга заголовков/инклудов (`fatal error: ... file not found`)

Причина: `libclang` не видит системные include-пути или проект требует специфичных флагов компиляции.

Что делать:
- Убедиться, что установлен компилятор (`cc`/`clang`/`gcc`) и доступен в `PATH`.
- Проверить, что системные заголовки реально установлены.
- Для сложных проектов с нестандартными флагами учитывать, что текущая версия индексатора парсит файлы как `-xc`/`-xc++` без `compile_commands.json`.

### 3. Не запускается `tui` (`Textual`/импортные ошибки)

Причина: не установлены зависимости.

Что делать:

```bash
python -m pip install -r requirements.txt
```

### 4. Низкая скорость на больших проектах

Что делать:
- Увеличить `--workers` (обычно до числа ядер CPU).
- Хранить БД на быстром диске (SSD).
- Пользоваться инкрементальной индексацией (повторный `index` уже быстрее за счёт пропуска неизмененных файлов).

## Технический принцип работы

### Компоненты

- `csig.py` — CLI-точка входа (`index`, `search`, `tui`).
- `csig_indexer.py` — многопоточный индексатор.
- `csig_core.py` — нормализация сигнатур, парсинг запроса, обход AST.
- `csig_db.py` — схема БД и SQL-операции.
- `csig_tui.py` — терминальный UI на Textual.

### Пайплайн индексации

1. Discovery-поток обходит дерево файлов.
2. Для C/C++/header-файлов проверяется состояние (`mtime`, `size`).
3. Неизмененные файлы помечаются как `skipped`.
4. Измененные отправляются в очередь задач.
5. Worker-потоки парсят файлы через `libclang` (`PARSE_SKIP_FUNCTION_BODIES`), извлекают `FUNCTION_DECL`.
6. Для каждой функции строится нормализованная сигнатура.
7. Writer-поток атомарно обновляет SQLite:
   - таблица `files`
   - таблица `functions` (перезапись функций для конкретного файла)
8. Возвращается summary: сколько файлов обработано/пропущено/с ошибками и сколько функций проиндексировано.

### Как устроен поиск

1. Строка запроса парсится как:
   - `<signature>`
   - `<name> :: <signature>`
2. Сигнатура нормализуется токенизацией через clang (чтобы сгладить различия в пробелах/форматировании).
3. Из БД выбираются кандидаты (`LIKE` по имени и/или сигнатуре).
4. Кандидаты ранжируются по расстоянию Левенштейна:
   - `name` vs `query.name`
   - `signature_norm` vs `query.normalised_signature`
5. Результаты сортируются по score, затем стабилизируются по имени/пути/позиции и обрезаются до `--top`.

### Формат вывода CLI

Для каждой найденной функции:

`<path>:<line>:<column>: <name> :: <return_type>(<params>)`

Пример:

`/repo/test.c:6:5: add :: int(int a, int b)`

## Полезные команды

```bash
python csig.py --help
python csig.py index --help
python csig.py search --help
python csig.py tui --help
pytest -q
```

## Ограничения текущей реализации

- Индексация выполняется с базовыми аргументами языка (`-xc`/`-xc++`) без чтения `compile_commands.json`.
- Из-за этого на проектах с нестандартными include/define-флагами могут быть диагностические ошибки парсинга.
- Поиск реализован как эвристический fuzzy match, а не строгий semantic-matching.
